/*

undefined
MaaS common components that are used consistently within our own objects

!!! AUTO GENERATED BY CONVERT.TS REFRAIN FROM MANUAL EDITING !!!

*/

import * as t from 'io-ts';
import * as Units_ from 'maas-schemas-ts/core/components/units';

export const schemaId = 'http://maasglobal.com/core/components/common.json';
// AgencyId
// The purpose of this remains a mystery
export type AgencyId = t.Branded<string, AgencyIdBrand>;
export const AgencyId = t.brand(
  t.string,
  (x): x is t.Branded<string, AgencyIdBrand> =>
    (typeof x !== 'string' || x.length >= 2) && (typeof x !== 'string' || x.length <= 64),
  'AgencyId',
);
export interface AgencyIdBrand {
  readonly AgencyId: unique symbol;
}
export const jsonAgencyIdExamples: Array<unknown> = [null];
export const safeAgencyIdExamples = t.array(AgencyId).decode(jsonAgencyIdExamples);

// DeviceToken
// The purpose of this remains a mystery
export type DeviceToken = t.Branded<string, DeviceTokenBrand>;
export const DeviceToken = t.brand(
  t.string,
  (x): x is t.Branded<string, DeviceTokenBrand> =>
    typeof x !== 'string' || x.match(RegExp('^([A-Fa-f0-9]{2}){8,64}$', 'u')) !== null,
  'DeviceToken',
);
export interface DeviceTokenBrand {
  readonly DeviceToken: unique symbol;
}
export const jsonDeviceTokenExamples: Array<unknown> = [null];
export const safeDeviceTokenExamples = t
  .array(DeviceToken)
  .decode(jsonDeviceTokenExamples);

// Signature
// Signature of a signed object
export type Signature = t.Branded<string, SignatureBrand>;
export const Signature = t.brand(
  t.string,
  (x): x is t.Branded<string, SignatureBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 1024),
  'Signature',
);
export interface SignatureBrand {
  readonly Signature: unique symbol;
}
export const jsonSignatureExamples: Array<unknown> = [null];
export const safeSignatureExamples = t.array(Signature).decode(jsonSignatureExamples);

// HtmlBlock
// HTML string of block level content
export type HtmlBlock = t.Branded<string, HtmlBlockBrand>;
export const HtmlBlock = t.brand(
  t.string,
  (x): x is t.Branded<string, HtmlBlockBrand> => true,
  'HtmlBlock',
);
export interface HtmlBlockBrand {
  readonly HtmlBlock: unique symbol;
}
export const jsonHtmlBlockExamples: Array<unknown> = [null];
export const safeHtmlBlockExamples = t.array(HtmlBlock).decode(jsonHtmlBlockExamples);

// JsonParam
// JSON encoded object or array
export type JsonParam = t.Branded<string, JsonParamBrand>;
export const JsonParam = t.brand(
  t.string,
  (x): x is t.Branded<string, JsonParamBrand> => typeof x !== 'string' || x.length >= 2,
  'JsonParam',
);
export interface JsonParamBrand {
  readonly JsonParam: unique symbol;
}
export const jsonJsonParamExamples: Array<unknown> = [null];
export const safeJsonParamExamples = t.array(JsonParam).decode(jsonJsonParamExamples);

// PersonalName
// First or last name of a customer (e.g. John)
export type PersonalName = t.Branded<string, PersonalNameBrand>;
export const PersonalName = t.brand(
  t.string,
  (x): x is t.Branded<string, PersonalNameBrand> =>
    (typeof x !== 'string' ||
      x.match(RegExp("^(?:\\p{L})+(?:[`'Â´\\-\\.,]?\\s?(?:\\p{L})*)*$", 'u')) !== null) &&
    (typeof x !== 'string' || x.length <= 255),
  'PersonalName',
);
export interface PersonalNameBrand {
  readonly PersonalName: unique symbol;
}
export const jsonPersonalNameExamples: Array<unknown> = [null];
export const safePersonalNameExamples = t
  .array(PersonalName)
  .decode(jsonPersonalNameExamples);

// Phone
// ITU-T E.164 phone number, see https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s03.html
export type Phone = t.Branded<string, PhoneBrand>;
export const Phone = t.brand(
  t.string,
  (x): x is t.Branded<string, PhoneBrand> =>
    typeof x !== 'string' || x.match(RegExp('^\\+(?:\\d){6,14}\\d$', 'u')) !== null,
  'Phone',
);
export interface PhoneBrand {
  readonly Phone: unique symbol;
}
export const jsonPhoneExamples: Array<unknown> = [null, '+358401234567'];
export const safePhoneExamples = t.array(Phone).decode(jsonPhoneExamples);

// RawPhone
// Slightly looser definition of phone number
export type RawPhone = t.Branded<string, RawPhoneBrand>;
export const RawPhone = t.brand(
  t.string,
  (x): x is t.Branded<string, RawPhoneBrand> =>
    typeof x !== 'string' || x.match(RegExp('^\\+?(?:\\d){6,14}\\d$', 'u')) !== null,
  'RawPhone',
);
export interface RawPhoneBrand {
  readonly RawPhone: unique symbol;
}
export const jsonRawPhoneExamples: Array<unknown> = [null];
export const safeRawPhoneExamples = t.array(RawPhone).decode(jsonRawPhoneExamples);

// Email
// Rough validation of a valid e-mail address, see https://davidcel.is/posts/stop-validating-email-addresses-with-regex/
export type Email = t.Branded<string, EmailBrand>;
export const Email = t.brand(
  t.string,
  (x): x is t.Branded<string, EmailBrand> =>
    (typeof x !== 'string' || x.match(RegExp('^.+@.+\\..+$', 'u')) !== null) &&
    (typeof x !== 'string' || x.length <= 64),
  'Email',
);
export interface EmailBrand {
  readonly Email: unique symbol;
}
export const jsonEmailExamples: Array<unknown> = [null, 'joe.customer@example.com'];
export const safeEmailExamples = t.array(Email).decode(jsonEmailExamples);

// CustomerReference
// Any unique way to refer a customer
export type CustomerReference = t.Branded<
  Units_.IdentityId | Phone,
  CustomerReferenceBrand
>;
export const CustomerReference = t.brand(
  t.union([Units_.IdentityId, Phone]),
  (x): x is t.Branded<Units_.IdentityId | Phone, CustomerReferenceBrand> => true,
  'CustomerReference',
);
export interface CustomerReferenceBrand {
  readonly CustomerReference: unique symbol;
}
export const jsonCustomerReferenceExamples: Array<unknown> = [
  null,
  '4828507e-683f-41bf-9d87-689808fbf958',
  '+358401234567',
];
export const safeCustomerReferenceExamples = t
  .array(CustomerReference)
  .decode(jsonCustomerReferenceExamples);

// LooseCustomerReference
// Any unique way to refer a customer, plus some opportunistic ways
export type LooseCustomerReference = t.Branded<
  CustomerReference | Email,
  LooseCustomerReferenceBrand
>;
export const LooseCustomerReference = t.brand(
  t.union([CustomerReference, Email]),
  (x): x is t.Branded<CustomerReference | Email, LooseCustomerReferenceBrand> => true,
  'LooseCustomerReference',
);
export interface LooseCustomerReferenceBrand {
  readonly LooseCustomerReference: unique symbol;
}
export const jsonLooseCustomerReferenceExamples: Array<unknown> = [
  null,
  '4828507e-683f-41bf-9d87-689808fbf958',
  '+358401234567',
  'joe.customer@example.com',
];
export const safeLooseCustomerReferenceExamples = t
  .array(LooseCustomerReference)
  .decode(jsonLooseCustomerReferenceExamples);

// PaymentSourceId
// The purpose of this remains a mystery
export type PaymentSourceId = t.Branded<string, PaymentSourceIdBrand>;
export const PaymentSourceId = t.brand(
  t.string,
  (x): x is t.Branded<string, PaymentSourceIdBrand> =>
    (typeof x !== 'string' || x.length >= 3) &&
    (typeof x !== 'string' || x.length <= 255),
  'PaymentSourceId',
);
export interface PaymentSourceIdBrand {
  readonly PaymentSourceId: unique symbol;
}
export const jsonPaymentSourceIdExamples: Array<unknown> = [null];
export const safePaymentSourceIdExamples = t
  .array(PaymentSourceId)
  .decode(jsonPaymentSourceIdExamples);

// AppInstanceId
// An id specific to a user device
export type AppInstanceId = t.Branded<string, AppInstanceIdBrand>;
export const AppInstanceId = t.brand(
  t.string,
  (x): x is t.Branded<string, AppInstanceIdBrand> =>
    typeof x !== 'string' || x.length >= 6,
  'AppInstanceId',
);
export interface AppInstanceIdBrand {
  readonly AppInstanceId: unique symbol;
}
export const jsonAppInstanceIdExamples: Array<unknown> = [null];
export const safeAppInstanceIdExamples = t
  .array(AppInstanceId)
  .decode(jsonAppInstanceIdExamples);

// OpaqueId
// Typically the hash of the identityId
export type OpaqueId = t.Branded<string, OpaqueIdBrand>;
export const OpaqueId = t.brand(
  t.string,
  (x): x is t.Branded<string, OpaqueIdBrand> =>
    typeof x !== 'string' || x.match(RegExp('^[0-9abcdefABCDEF]+$', 'u')) !== null,
  'OpaqueId',
);
export interface OpaqueIdBrand {
  readonly OpaqueId: unique symbol;
}
export const jsonOpaqueIdExamples: Array<unknown> = [null];
export const safeOpaqueIdExamples = t.array(OpaqueId).decode(jsonOpaqueIdExamples);

// ClientId
// An id indicating the source of the client
export type ClientId = t.Branded<string & ('whim' | 'wechat'), ClientIdBrand>;
export const ClientId = t.brand(
  t.intersection([t.string, t.union([t.literal('whim'), t.literal('wechat')])]),
  (x): x is t.Branded<string & ('whim' | 'wechat'), ClientIdBrand> => true,
  'ClientId',
);
export interface ClientIdBrand {
  readonly ClientId: unique symbol;
}
export const jsonClientIdExamples: Array<unknown> = [null];
export const safeClientIdExamples = t.array(ClientId).decode(jsonClientIdExamples);

// Ssid
// Social Security ID
export type Ssid = t.Branded<string, SsidBrand>;
export const Ssid = t.brand(
  t.string,
  (x): x is t.Branded<string, SsidBrand> => typeof x !== 'string' || x.length >= 4,
  'Ssid',
);
export interface SsidBrand {
  readonly Ssid: unique symbol;
}
export const jsonSsidExamples: Array<unknown> = [null];
export const safeSsidExamples = t.array(Ssid).decode(jsonSsidExamples);

// EncodedQueryParam
// Encoded Query Params
export type EncodedQueryParam = t.Branded<string, EncodedQueryParamBrand>;
export const EncodedQueryParam = t.brand(
  t.string,
  (x): x is t.Branded<string, EncodedQueryParamBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 8192),
  'EncodedQueryParam',
);
export interface EncodedQueryParamBrand {
  readonly EncodedQueryParam: unique symbol;
}
export const jsonEncodedQueryParamExamples: Array<unknown> = [null];
export const safeEncodedQueryParamExamples = t
  .array(EncodedQueryParam)
  .decode(jsonEncodedQueryParamExamples);

// ErrorKey
// Error key
export type ErrorKey = t.Branded<string, ErrorKeyBrand>;
export const ErrorKey = t.brand(
  t.string,
  (x): x is t.Branded<string, ErrorKeyBrand> =>
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 255),
  'ErrorKey',
);
export interface ErrorKeyBrand {
  readonly ErrorKey: unique symbol;
}
export const jsonErrorKeyExamples: Array<unknown> = [null];
export const safeErrorKeyExamples = t.array(ErrorKey).decode(jsonErrorKeyExamples);

// WhimDeepLink
// Whim only deep link to localhost and freely defined view - not a complete URI validation
export type WhimDeepLink = t.Branded<string, WhimDeepLinkBrand>;
export const WhimDeepLink = t.brand(
  t.string,
  (x): x is t.Branded<string, WhimDeepLinkBrand> =>
    typeof x !== 'string' ||
    x.match(RegExp('^(whim):\\/\\/\\/[^\\s/$.?#].[^\\s]*$', 'u')) !== null,
  'WhimDeepLink',
);
export interface WhimDeepLinkBrand {
  readonly WhimDeepLink: unique symbol;
}
export const jsonWhimDeepLinkExamples: Array<unknown> = [null];
export const safeWhimDeepLinkExamples = t
  .array(WhimDeepLink)
  .decode(jsonWhimDeepLinkExamples);

// Default
// The default export. More information at the top.
export type Default = t.Branded<unknown, DefaultBrand>;
export const Default = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, DefaultBrand> => true,
  'Default',
);
export interface DefaultBrand {
  readonly Default: unique symbol;
}
export const jsonDefaultExamples: Array<unknown> = [null];
export const safeDefaultExamples = t.array(Default).decode(jsonDefaultExamples);

export default Default;

// Success
