/*

undefined
MaaS common units that are used consistently within our own objects

!!! AUTO GENERATED BY CONVERT.TS REFRAIN FROM MANUAL EDITING !!!

*/

import * as t from 'io-ts';
import { NonEmptyArray } from 'fp-ts/lib/NonEmptyArray';
import { nonEmptyArray } from 'io-ts-types/lib/nonEmptyArray';

export const schemaId = 'http://maasglobal.com/core/components/units.json';

// Uuid
// Universally unique identifier, see https://en.wikipedia.org/wiki/Universally_unique_identifier
export type Uuid = t.Branded<string, UuidBrand>;
export const Uuid = t.brand(
  t.string,
  (x): x is t.Branded<string, UuidBrand> =>
    typeof x !== 'string' ||
    x.match(RegExp('^[A-Fa-f0-9]{8}(-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12}$')) !== null,
  'Uuid',
);
export interface UuidBrand {
  readonly Uuid: unique symbol;
}
/** examplesUuid // => { _tag: 'Right', right: examplesUuidJson } */
export const examplesUuidJson: NonEmptyArray<unknown> = [
  '4828507e-683f-41bf-9d87-689808fbf958',
];
export const examplesUuid = nonEmptyArray(Uuid).decode(examplesUuidJson);

// Url
// Uniform resource locator, see https://en.wikipedia.org/wiki/Uniform_Resource_Locator and https://mathiasbynens.be/demo/url-regex
export type Url = t.Branded<string, UrlBrand>;
export const Url = t.brand(
  t.string,
  (x): x is t.Branded<string, UrlBrand> =>
    typeof x !== 'string' ||
    x.match(RegExp('^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$')) !== null,
  'Url',
);
export interface UrlBrand {
  readonly Url: unique symbol;
}

// Arn
// The purpose of this remains a mystery
export type Arn = t.Branded<string, ArnBrand>;
export const Arn = t.brand(
  t.string,
  (x): x is t.Branded<string, ArnBrand> =>
    (typeof x !== 'string' ||
      x.match(
        RegExp('^arn:aws:[a-z]+:[\\w\\-]*:\\d{12}:[ \\w\\-]+(\\/[\\w\\- \\/]+)*'),
      ) !== null) &&
    (typeof x !== 'string' || x.length >= 1) &&
    (typeof x !== 'string' || x.length <= 256),
  'Arn',
);
export interface ArnBrand {
  readonly Arn: unique symbol;
}

// ObsoleteIdentityId
// The purpose of this remains a mystery
export type ObsoleteIdentityId = t.Branded<string, ObsoleteIdentityIdBrand>;
export const ObsoleteIdentityId = t.brand(
  t.string,
  (x): x is t.Branded<string, ObsoleteIdentityIdBrand> =>
    typeof x !== 'string' ||
    x.match(
      RegExp('^[aepus]{2}-[\\w]{4}-\\d:[a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}$'),
    ) !== null,
  'ObsoleteIdentityId',
);
export interface ObsoleteIdentityIdBrand {
  readonly ObsoleteIdentityId: unique symbol;
}
/** examplesObsoleteIdentityId // => { _tag: 'Right', right: examplesObsoleteIdentityIdJson } */
export const examplesObsoleteIdentityIdJson: NonEmptyArray<unknown> = [
  'eu-west-1:4828507e-683f-41bf-9d87-689808fbf958',
];
export const examplesObsoleteIdentityId = nonEmptyArray(ObsoleteIdentityId).decode(
  examplesObsoleteIdentityIdJson,
);

// IdentityId
// The purpose of this remains a mystery
export type IdentityId = t.Branded<ObsoleteIdentityId | Uuid, IdentityIdBrand>;
export const IdentityId = t.brand(
  t.union([ObsoleteIdentityId, Uuid]),
  (x): x is t.Branded<ObsoleteIdentityId | Uuid, IdentityIdBrand> => true,
  'IdentityId',
);
export interface IdentityIdBrand {
  readonly IdentityId: unique symbol;
}
/** examplesIdentityId // => { _tag: 'Right', right: examplesIdentityIdJson } */
export const examplesIdentityIdJson: NonEmptyArray<unknown> = [
  'eu-west-1:4828507e-683f-41bf-9d87-689808fbf958',
  '4828507e-683f-41bf-9d87-689808fbf958',
];
export const examplesIdentityId = nonEmptyArray(IdentityId).decode(
  examplesIdentityIdJson,
);

// CurrencyEUR
// The purpose of this remains a mystery
export type CurrencyEUR = t.Branded<'EUR', CurrencyEURBrand>;
export const CurrencyEUR = t.brand(
  t.literal('EUR'),
  (x): x is t.Branded<'EUR', CurrencyEURBrand> => true,
  'CurrencyEUR',
);
export interface CurrencyEURBrand {
  readonly CurrencyEUR: unique symbol;
}

// CurrencyGBP
// The purpose of this remains a mystery
export type CurrencyGBP = t.Branded<'GBP', CurrencyGBPBrand>;
export const CurrencyGBP = t.brand(
  t.literal('GBP'),
  (x): x is t.Branded<'GBP', CurrencyGBPBrand> => true,
  'CurrencyGBP',
);
export interface CurrencyGBPBrand {
  readonly CurrencyGBP: unique symbol;
}

// CurrencySGD
// The purpose of this remains a mystery
export type CurrencySGD = t.Branded<'SGD', CurrencySGDBrand>;
export const CurrencySGD = t.brand(
  t.literal('SGD'),
  (x): x is t.Branded<'SGD', CurrencySGDBrand> => true,
  'CurrencySGD',
);
export interface CurrencySGDBrand {
  readonly CurrencySGD: unique symbol;
}

// CurrencyUSD
// The purpose of this remains a mystery
export type CurrencyUSD = t.Branded<'USD', CurrencyUSDBrand>;
export const CurrencyUSD = t.brand(
  t.literal('USD'),
  (x): x is t.Branded<'USD', CurrencyUSDBrand> => true,
  'CurrencyUSD',
);
export interface CurrencyUSDBrand {
  readonly CurrencyUSD: unique symbol;
}

// CurrencyJPY
// The purpose of this remains a mystery
export type CurrencyJPY = t.Branded<'JPY', CurrencyJPYBrand>;
export const CurrencyJPY = t.brand(
  t.literal('JPY'),
  (x): x is t.Branded<'JPY', CurrencyJPYBrand> => true,
  'CurrencyJPY',
);
export interface CurrencyJPYBrand {
  readonly CurrencyJPY: unique symbol;
}

// Currency
// Accepted monetary unit in ISO 4127 format, see https://en.wikipedia.org/wiki/ISO_4217#cite_note-1
export type Currency = t.Branded<
  string & (CurrencyEUR | CurrencyGBP | CurrencySGD | CurrencyUSD | CurrencyJPY),
  CurrencyBrand
>;
export const Currency = t.brand(
  t.intersection([
    t.string,
    t.union([CurrencyEUR, CurrencyGBP, CurrencySGD, CurrencyUSD, CurrencyJPY]),
  ]),
  (
    x,
  ): x is t.Branded<
    string & (CurrencyEUR | CurrencyGBP | CurrencySGD | CurrencyUSD | CurrencyJPY),
    CurrencyBrand
  > => true,
  'Currency',
);
export interface CurrencyBrand {
  readonly Currency: unique symbol;
}

// MetaCurrencyWMP
// The purpose of this remains a mystery
export type MetaCurrencyWMP = t.Branded<'WMP', MetaCurrencyWMPBrand>;
export const MetaCurrencyWMP = t.brand(
  t.literal('WMP'),
  (x): x is t.Branded<'WMP', MetaCurrencyWMPBrand> => true,
  'MetaCurrencyWMP',
);
export interface MetaCurrencyWMPBrand {
  readonly MetaCurrencyWMP: unique symbol;
}

// MetaCurrencyTOKEN
// The purpose of this remains a mystery
export type MetaCurrencyTOKEN = t.Branded<'TOKEN', MetaCurrencyTOKENBrand>;
export const MetaCurrencyTOKEN = t.brand(
  t.literal('TOKEN'),
  (x): x is t.Branded<'TOKEN', MetaCurrencyTOKENBrand> => true,
  'MetaCurrencyTOKEN',
);
export interface MetaCurrencyTOKENBrand {
  readonly MetaCurrencyTOKEN: unique symbol;
}

// MetaCurrency
// The purpose of this remains a mystery
export type MetaCurrency = t.Branded<
  string & (MetaCurrencyWMP | MetaCurrencyTOKEN),
  MetaCurrencyBrand
>;
export const MetaCurrency = t.brand(
  t.intersection([t.string, t.union([MetaCurrencyWMP, MetaCurrencyTOKEN])]),
  (
    x,
  ): x is t.Branded<string & (MetaCurrencyWMP | MetaCurrencyTOKEN), MetaCurrencyBrand> =>
    true,
  'MetaCurrency',
);
export interface MetaCurrencyBrand {
  readonly MetaCurrency: unique symbol;
}

// Time
// POSIX time in milliseconds, https://en.wikipedia.org/wiki/Unix_time
export type Time = t.Branded<number, TimeBrand>;
export const Time = t.brand(
  t.number,
  (x): x is t.Branded<number, TimeBrand> =>
    (typeof x !== 'number' || x >= 1451606400) &&
    (typeof x !== 'number' || x <= 9007199254740991) &&
    Number.isInteger(x),
  'Time',
);
export interface TimeBrand {
  readonly Time: unique symbol;
}

// Duration
// duration in milliseconds (negative values permitted), https://en.wikipedia.org/wiki/Unix_time
export type Duration = t.Branded<number, DurationBrand>;
export const Duration = t.brand(
  t.number,
  (x): x is t.Branded<number, DurationBrand> =>
    (typeof x !== 'number' || x >= -9007199254740991) &&
    (typeof x !== 'number' || x <= 9007199254740991) &&
    Number.isInteger(x),
  'Duration',
);
export interface DurationBrand {
  readonly Duration: unique symbol;
}

// IsoDate
// A date in the form YYYY-MM-DD without a time component
export type IsoDate = t.Branded<string, IsoDateBrand>;
export const IsoDate = t.brand(
  t.string,
  (x): x is t.Branded<string, IsoDateBrand> =>
    typeof x !== 'string' || x.match(RegExp('^\\d{4}-\\d{2}-\\d{2}')) !== null,
  'IsoDate',
);
export interface IsoDateBrand {
  readonly IsoDate: unique symbol;
}

// Units
// The default export. More information at the top.
export type Units = t.Branded<unknown, UnitsBrand>;
export const Units = t.brand(
  t.unknown,
  (x): x is t.Branded<unknown, UnitsBrand> => true,
  'Units',
);
export interface UnitsBrand {
  readonly Units: unique symbol;
}

export default Units;

// Success
